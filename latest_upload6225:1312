#include <Wire.h>
#include <Servo.h>

// ==================
// 74HC595 Control
// ==================
int latchPin = 5;   // Conectat la RCLK (Pin 12 pe 74HC595)
int clockPin = 6;   // Conectat la SRCLK (Pin 11 pe 74HC595)
int dataPin = 4;    // Conectat la SER (Pin 14 pe 74HC595)
int oePin = 3;      // Conectat la OE (Pin 13 pe 74HC595) - control PWM

// ==================
// Servo și Senzori
// ==================
int servo1Pin = 9;  // Pin PWM pentru Servo 1
int servo2Pin = 10; // Pin PWM pentru Servo 2

Servo servo1;
Servo servo2;

const int servo1SensorPin = A1;  // Senzor curent Servo 1
const int servo2SensorPin = A2;  // Senzor curent Servo 2

const int errorPin = 2;  // Pin de semnalizare eroare

// Unghiurile curente ale servomotoarelor
int servo1CurrentAngle = 0;
int servo2CurrentAngle = 0;

// ==================
// Configurare Timeout
// ==================
const unsigned long TIMEOUT_MS = 300;
unsigned long lastCommandTime = 0;

// ==================
// Constante pentru monitorizarea curentului la servomotoare
// ==================
const float SERVO_FORWARD_THRESHOLD = 0.0100;
const float SERVO_BACKWARD_THRESHOLD = 0.0100;

// ==================
// Mod Debug
// ==================
bool debugMode = false;

// ==================
// Funcții Utilitare
// ==================

// (Funcția getDirectionText este păstrată doar pentru referință internă.)
const char* getDirectionText(uint8_t direction) {
  switch(direction) {
    case 0:  return "STOP";
    case 1:  return "FORWARD";
    case 2:  return "RIGHT";
    case 3:  return "LEFT";
    case 4:  return "SLIGHTLY RIGHT";
    case 5:  return "SLIGHTLY LEFT";
    case 6:  return "DIAGONAL RIGHT";
    case 7:  return "DIAGONAL LEFT";
    case 8:  return "HARD TURN LEFT";
    case 9:  return "HARD TURN RIGHT";
    case 10: return "LEFT ROTATE";
    case 11: return "RIGHT ROTATE";
    case 12: return "BACKWARD";
    case 56: return "DEBUG_MODE";
    default: return "UNKNOWN";
  }
}

byte getMovementByte(uint8_t direction) {
  switch(direction) {
    case 0:  return 0b00000000; // STOP
    case 1:  return 0b01010101; // FORWARD
    case 2:  return 0b10010000; // RIGHT
    case 3:  return 0b01100000; // LEFT
    case 4:  return 0b00000110; // SLIGHTLY RIGHT
    case 5:  return 0b00001001; // SLIGHTLY LEFT
    case 6:  return 0b01000100; // DIAGONAL RIGHT
    case 7:  return 0b10001000; // DIAGONAL LEFT
    case 8:  return 0b00010100; // HARD TURN LEFT
    case 9:  return 0b00101000; // HARD TURN RIGHT
    case 10: return 0b01101001; // LEFT ROTATE
    case 11: return 0b10010110; // RIGHT ROTATE
    case 12: return 0b10101010; // BACKWARD
    default: return 0b00000000; // Implicit STOP
  }
}

void updateShiftRegister(byte data) {
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, data);
  digitalWrite(latchPin, HIGH);
}

void setMotorSpeed(uint8_t speed) {
  analogWrite(oePin, speed);
}

// ==================
// Funcție pentru citirea senzorului de curent
// ==================
float readCurrentSensor(int sensorPin) {
  float samples = 0.0, avgVal = 0.0, currentVal = 0.0;
  float minVal = 1023, maxVal = 0;  
  for (int x = 0; x < 500; x++) {
    float sample = analogRead(sensorPin);
    samples += sample;
    if (sample < minVal) minVal = sample;
    if (sample > maxVal) maxVal = sample;
  }
  samples -= (minVal + maxVal);
  avgVal = samples / 498.0;  
  currentVal = (2.5 - (avgVal * (5.0 / 1024.0))) / 0.185;  
  return currentVal;
}

// ==================
// Mișcarea servo cu monitorizarea curentului
// ==================
bool moveServoWithCurrentMonitoring(Servo &servo, int &currentAngle, int targetAngle, int sensorPin) {
  int tries = 0;
  const int maxTries = 4;
  const int stepSize = 1;
  const int retractDegrees = 20;
  bool movingForward = (targetAngle > currentAngle);
  
  while (currentAngle != targetAngle && tries < maxTries) {
    bool thresholdTriggered = false;
    if (movingForward) {
      for (int angle = currentAngle; angle <= targetAngle; angle += stepSize) {
        if (angle > targetAngle) angle = targetAngle;
        servo.write(angle);
        delay(5);
        float currentVal = readCurrentSensor(sensorPin);
        if (currentVal >= SERVO_FORWARD_THRESHOLD) {
          thresholdTriggered = true;
          break;
        }
        currentAngle = angle;
        if (currentAngle == targetAngle) return true;
      }
    } else { // Mișcare inversă
      for (int angle = currentAngle; angle >= targetAngle; angle -= stepSize) {
        if (angle < targetAngle) angle = targetAngle;
        servo.write(angle);
        delay(5);
        float currentVal = readCurrentSensor(sensorPin);
        if ((-1 * currentVal) >= SERVO_BACKWARD_THRESHOLD) {
          thresholdTriggered = true;
          break;
        }
        currentAngle = angle;
        if (currentAngle == targetAngle) return true;
      }
    }
    
    if (thresholdTriggered) {
      tries++;
      if (movingForward) {
        currentAngle = max(currentAngle - retractDegrees, 0);
      } else {
        currentAngle = min(currentAngle + retractDegrees, 180);
      }
      servo.write(currentAngle);
      delay(2000);
    }
  }
  
  if (tries >= maxTries) {
    currentAngle = 0;
    servo.write(0);
    digitalWrite(errorPin, HIGH);
    return false;
  }
  
  return true;
}

// ==================
// Handler pentru comenzile servo
// ==================
void handleServoCommand(uint16_t command) {
  uint8_t servoIndex = command / 100; // De exemplu, 180 pentru Servo 1 sau 181 pentru Servo 2
  uint8_t angle = command % 100;       // Unghiul țintă (0-99, folosit direct ca unghi)
  uint8_t servoAngle = angle;
  
  switch (servoIndex) {
    case 180:
      moveServoWithCurrentMonitoring(servo1, servo1CurrentAngle, servoAngle, servo1SensorPin);
      break;
    case 181:
      moveServoWithCurrentMonitoring(servo2, servo2CurrentAngle, servoAngle, servo2SensorPin);
      break;
    default:
      break;
  }
}

// ==================
// (Funcția convertDebugHex a fost eliminată din modul debug, deoarece în modul debug 
//  se dorește ca directia să fie preluată direct ca o valoare numerică 0-255.)
// ==================

// ==================
// Handler pentru evenimentul I2C (receiveEvent)
// ==================
void receiveEvent(int howMany) {
  while (howMany >= 3) {
    uint8_t speed = Wire.read();
    uint8_t byte1 = Wire.read();
    uint8_t byte2 = Wire.read();
    howMany -= 3;
    
    // Verificare pentru comanda de toggle debug:
    // Dacă viteza este 7 și cei doi octeți reprezintă caracterele '5' și '6'
    if (speed == 7 && byte1 == '5' && byte2 == '6') {
      debugMode = !debugMode;
      continue;
    }
    
    if (debugMode) {
      // În modul debug, se prelucrează comanda ca o valoare numerică (0-255)
      // (se ignoră orice comandă legată de servomotoare)
      uint16_t direction = (byte1 << 8) | byte2;
      // Ne asigurăm că valoarea folosită este în intervalul 0-255:
      byte debugByte = direction & 0xFF;
      setMotorSpeed(speed);
      updateShiftRegister(debugByte);
    } else {
      // În modul normal se prelucrează cei doi octeți ca valori numerice
      uint16_t direction = (byte1 << 8) | byte2;
      if (direction >= 180 && direction <= 189) {
        handleServoCommand(direction);
      } else {
        setMotorSpeed(speed);
        byte movementByte = getMovementByte(direction);
        updateShiftRegister(movementByte);
      }
    }
    lastCommandTime = millis();
  }
}

// ==================
// setup()
// ==================
void setup() {
  // Inițializare pini pentru 74HC595
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(oePin, OUTPUT);
  
  // Inițializare pin eroare
  pinMode(errorPin, OUTPUT);
  digitalWrite(errorPin, LOW);
  
  // Atașare servomotoare
  servo1.attach(servo1Pin);
  servo2.attach(servo2Pin);
  
  // Inițializare PWM (viteza 0)
  analogWrite(oePin, 0);
  
  // Setare inițială a registrului de shift la STOP
  updateShiftRegister(0b00000000);
  
  // Inițializare I2C la adresa 8 și setare handler pentru recepție
  Wire.begin(8);
  Wire.onReceive(receiveEvent);
  
  lastCommandTime = millis();
}

// ==================
// loop()
// ==================
void loop() {
  if (millis() - lastCommandTime > TIMEOUT_MS) {
    setMotorSpeed(0);
    updateShiftRegister(0b00000000);
  }
  delay(90);
}
